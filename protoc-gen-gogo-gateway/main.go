// Protocol Buffers for Go with Gadgets
//
// Copyright (c) 2016, The GoGo Authors. All rights reserved.
// http://github.com/gogo/protobuf
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

package main

import (
	"bytes"
	"go/ast"
	"go/parser"
	"go/printer"
	"go/token"
	"os"
	"os/exec"

	"github.com/gogo/protobuf/gogoproto"
	"github.com/gogo/protobuf/proto"
	descriptor "github.com/gogo/protobuf/protoc-gen-gogo/descriptor"
	"github.com/gogo/protobuf/protoc-gen-gogo/generator"
	plugin "github.com/gogo/protobuf/protoc-gen-gogo/plugin"
	"github.com/gogo/protobuf/vanity/command"
)

func main() {
	command.Write(forwardAndFix(command.Read()))
}

// Forward request to protoc-gen-grpc-gateway plugin.
// CodeGeneratorRequest will be pass to protoc-gen-grpc-gateway as is.
// CodeGeneratorResponse will be modified in order to fix the gogoproto.customname issue.
func forwardAndFix(req *plugin.CodeGeneratorRequest) *plugin.CodeGeneratorResponse {
	resp := new(plugin.CodeGeneratorResponse)

	reqData, err := proto.Marshal(req)
	if err != nil {
		resp.Error = stringToPointer(err.Error())
		return resp
	}

	input := bytes.NewBuffer(reqData)
	output := new(bytes.Buffer)

	cmd := exec.Command("protoc-gen-grpc-gateway", os.Args[1:]...)
	cmd.Stdin = input
	cmd.Stdout = output
	cmd.Stderr = os.Stderr

	err = cmd.Run()
	if err != nil {
		resp.Error = stringToPointer(err.Error())
		return resp
	}

	err = proto.Unmarshal(output.Bytes(), resp)
	if err != nil {
		resp.Error = stringToPointer(err.Error())
		return resp
	}

	err = fix(req, resp)
	if err != nil {
		resp.Error = stringToPointer(err.Error())
		return resp
	}

	return resp
}

var fset = token.NewFileSet()

func fix(req *plugin.CodeGeneratorRequest, resp *plugin.CodeGeneratorResponse) error {
	for _, file := range resp.GetFile() {
		fixData, err := fixFile(req, file.GetContent())
		if err != nil {
			return err
		}
		file.Content = stringToPointer(fixData)
	}
	return nil
}

func fixFile(req *plugin.CodeGeneratorRequest, content string) (string, error) {
	// Parse the code generated by protoc-gen-grpc-gateway with the go ast framework
	node, err := parser.ParseFile(fset, "", content, parser.AllErrors)
	if err != nil {
		return "", err
	}

	// Walk the ast tree
	ast.Inspect(node, func(n ast.Node) bool {
		// Look for an assignment
		as, ok := n.(*ast.AssignStmt)
		if !ok {
			return true
		}

		// Take the left-hand side
		for _, expr := range as.Lhs {
			se, ok := expr.(*ast.SelectorExpr)
			if !ok {
				return true
			}

			id, ok := se.X.(*ast.Ident)
			if !ok {
				return true
			}

			// We know what we are looking for, the variable generated
			// by protoc-gen-grpc-gateway is called "protoReq"
			if id.Name == "protoReq" {
				vs, ok := id.Obj.Decl.(*ast.ValueSpec)
				if !ok {
					return true
				}

				// get the "type of protoReq"
				tID, ok := vs.Type.(*ast.Ident)
				if !ok {
					return true
				}

				// check if "type of protoReq" has a matching proto message
				protoMessage := findProtoMessage(req, tID.Name)

				// check every field to test if it uses customname
				for _, field := range protoMessage.GetField() {
					if gogoproto.IsCustomName(field) {
						if se.Sel.Name == generator.CamelCase(*field.Name) {
							// if so, update field
							se.Sel.Name = gogoproto.GetCustomName(field)
						}
					}
				}
			}
		}

		return true
	})

	// Write updated ast node back to CodeGeneratorResponse
	var buf bytes.Buffer
	err = printer.Fprint(&buf, fset, node)
	if err != nil {
		return "", err
	}

	return buf.String(), nil
}

// helper for ptr string assignments
func stringToPointer(s string) *string {
	return &s
}

// helper to find a message ny name
func findProtoMessage(req *plugin.CodeGeneratorRequest, name string) *descriptor.DescriptorProto {
	for _, protoFile := range req.GetProtoFile() {
		for _, message := range protoFile.GetMessageType() {
			if message.GetName() == name {
				return message
			}
		}
	}
	return nil
}
